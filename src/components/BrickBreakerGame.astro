<div class="BrickBreakerGame_container hidden">
  <div class="BrickBreakerGame_stats">
    <div class="BrickBreakerGame_score">
      Score: <span id="scoreValue">0</span>
    </div>
    <div class="BrickBreakerGame_lives">
      Lives: <span id="livesValue">3</span>
    </div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <button class="BrickBreakerGame_startBtn" id="startButton">Start Game</button>
</div>

<script>
  // Type definitions
  interface Paddle {
    width: number;
    height: number;
    x: number;
    y: number;
  }

  interface Ball {
    radius: number;
    x: number;
    y: number;
    dx: number;
    dy: number;
  }

  interface Brick {
    x: number;
    y: number;
    width: number;
    height: number;
    color: string;
    visible: boolean;
  }

  interface BrickConfig {
    rows: number;
    cols: number;
    padding: number;
    width: number;
    height: number;
    colors: string[];
  }

  class BrickBreakerGame {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    score: number;
    lives: number;
    gameStarted: boolean;
    paddle: Paddle;
    ball: Ball;
    bricks: Brick[];
    brickConfig: BrickConfig;

    constructor() {
      // Wait for container to be visible before initializing
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (
            mutation.target.classList &&
            !mutation.target.classList.contains("hidden")
          ) {
            this.initGame();
            observer.disconnect();
          }
        });
      });

      const container = document.querySelector(".BrickBreakerGame_container");
      if (container) {
        observer.observe(container, { attributes: true });
      }
    }

    initGame() {
      this.canvas = document.getElementById("gameCanvas") as HTMLCanvasElement;
      if (!this.canvas) return;

      this.ctx = this.canvas.getContext("2d") as CanvasRenderingContext2D;
      this.lives = 3;
      this.score = 0;
      this.gameStarted = false;

      // Set canvas size based on container
      const container = document.querySelector(".BrickBreakerGame_container");
      if (!container) return;

      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;

      this.canvas.width = Math.min(800, containerWidth * 0.95);
      this.canvas.height = Math.min(600, containerHeight * 0.8);

      // Game objects
      this.paddle = {
        width: this.canvas.width * 0.15,
        height: 20,
        x: this.canvas.width / 2 - (this.canvas.width * 0.15) / 2,
        y: this.canvas.height - 30,
      };

      this.ball = {
        radius: 8,
        x: this.canvas.width / 2,
        y: this.canvas.height - 50,
        dx: 5,
        dy: -5,
      };

      // Create bricks
      this.bricks = [];
      this.brickConfig = {
        rows: 5,
        cols: 8,
        padding: 10,
        width: (this.canvas.width - 100) / 8,
        height: 20,
        colors: ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF"],
      };

      this.initBricks();
      this.bindEvents();
      this.draw();
    }

    initBricks() {
      this.bricks = [];
      for (let row = 0; row < this.brickConfig.rows; row++) {
        for (let col = 0; col < this.brickConfig.cols; col++) {
          const brick = {
            x: col * (this.brickConfig.width + this.brickConfig.padding) + 50,
            y: row * (this.brickConfig.height + this.brickConfig.padding) + 50,
            width: this.brickConfig.width,
            height: this.brickConfig.height,
            color: this.brickConfig.colors[row],
            visible: true,
          };
          this.bricks.push(brick);
        }
      }
    }

    bindEvents() {
      // Touch events for paddle movement
      this.canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const relativeX = touch.clientX - rect.left;

        if (relativeX > 0 && relativeX < this.canvas.width) {
          this.paddle.x = relativeX - this.paddle.width / 2;
        }
      });

      // Mouse events for desktop play
      this.canvas.addEventListener("mousemove", (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const relativeX = e.clientX - rect.left;

        if (relativeX > 0 && relativeX < this.canvas.width) {
          this.paddle.x = relativeX - this.paddle.width / 2;
        }
      });

      // Start button
      const startButton = document.getElementById("startButton");
      if (startButton) {
        startButton.addEventListener("click", () => {
          this.gameStarted = true;
          startButton.style.display = "none";
          this.gameLoop();
        });
      }
    }

    update() {
      // Ball movement
      this.ball.x += this.ball.dx;
      this.ball.y += this.ball.dy;

      // Wall collision
      if (
        this.ball.x + this.ball.radius > this.canvas.width ||
        this.ball.x - this.ball.radius < 0
      ) {
        this.ball.dx = -this.ball.dx;
      }
      if (this.ball.y - this.ball.radius < 0) {
        this.ball.dy = -this.ball.dy;
      }

      // Paddle collision
      if (
        this.ball.y + this.ball.radius > this.paddle.y &&
        this.ball.x > this.paddle.x &&
        this.ball.x < this.paddle.x + this.paddle.width &&
        this.ball.y < this.paddle.y + this.paddle.height
      ) {
        this.ball.dy = -this.ball.dy;

        // Add angle based on where the ball hits the paddle
        const hitPoint = (this.ball.x - this.paddle.x) / this.paddle.width;
        this.ball.dx = 8 * (hitPoint - 0.5);
      }

      // Brick collision
      this.bricks.forEach((brick) => {
        if (!brick.visible) return;

        // Calculate distances between ball and brick
        const ballLeft = this.ball.x - this.ball.radius;
        const ballRight = this.ball.x + this.ball.radius;
        const ballTop = this.ball.y - this.ball.radius;
        const ballBottom = this.ball.y + this.ball.radius;

        const brickLeft = brick.x;
        const brickRight = brick.x + brick.width;
        const brickTop = brick.y;
        const brickBottom = brick.y + brick.height;

        // Check collision
        if (
          ballRight > brickLeft &&
          ballLeft < brickRight &&
          ballBottom > brickTop &&
          ballTop < brickBottom
        ) {
          // Determine collision direction
          const fromBottom = Math.abs(ballTop - brickBottom);
          const fromTop = Math.abs(ballBottom - brickTop);
          const fromLeft = Math.abs(ballRight - brickLeft);
          const fromRight = Math.abs(ballLeft - brickRight);

          const min = Math.min(fromBottom, fromTop, fromLeft, fromRight);

          // Bounce in appropriate direction
          if (min === fromTop || min === fromBottom) {
            this.ball.dy = -this.ball.dy;
          } else {
            this.ball.dx = -this.ball.dx;
          }

          brick.visible = false;
          this.score += 10;
          document.getElementById("scoreValue").textContent =
            this.score.toString();

          // Check if all bricks are cleared
          if (this.bricks.every((b) => !b.visible)) {
            this.levelComplete();
          }
        }
      });

      // Game over
      if (this.ball.y + this.ball.radius > this.canvas.height) {
        this.lives--;
        document.getElementById("livesValue").textContent =
          this.lives.toString();

        if (this.lives <= 0) {
          this.gameStarted = false;
          const container = document.querySelector(
            ".BrickBreakerGame_container"
          );
          if (container) {
            container.classList.add("hidden");
          }
          // Reset everything for the next game
          this.reset();
          // Reset paddle width and ball speed that might have been modified in previous levels
          this.ball.dx = 5;
          this.ball.dy = -5;
          this.paddle.width = this.canvas.width * 0.15;
        } else {
          this.gameStarted = false;
          const startButton = document.getElementById("startButton");
          if (startButton) {
            startButton.style.display = "block";
            startButton.textContent = "Continue";
          }
          // Reset ball and paddle position without resetting score
          this.ball.x = this.canvas.width / 2;
          this.ball.y = this.canvas.height - 50;
          this.ball.dx = 5;
          this.ball.dy = -5;
          this.paddle.x = this.canvas.width / 2 - this.paddle.width / 2;
        }
      }
    }

    levelComplete() {
      // Handle level completion
      this.gameStarted = false;
      const startButton = document.getElementById("startButton");
      if (startButton) {
        startButton.style.display = "block";
        startButton.textContent = "Next Level";
      }

      // Increase difficulty for next level
      this.ball.dx *= 1.2;
      this.ball.dy *= 1.2;
      this.paddle.width *= 0.9;

      // Reset ball and paddle position
      this.ball.x = this.canvas.width / 2;
      this.ball.y = this.canvas.height - 50;
      this.paddle.x = this.canvas.width / 2 - this.paddle.width / 2;

      // Create new bricks
      this.initBricks();
    }

    reset() {
      this.score = 0;
      this.lives = 3;
      const scoreElement = document.getElementById("scoreValue");
      const livesElement = document.getElementById("livesValue");

      if (scoreElement) {
        scoreElement.textContent = this.score.toString();
      }
      if (livesElement) {
        livesElement.textContent = this.lives.toString();
      }

      this.ball.x = this.canvas.width / 2;
      this.ball.y = this.canvas.height - 50;
      this.ball.dx = 5;
      this.ball.dy = -5;
      this.paddle.x = this.canvas.width / 2 - this.paddle.width / 2;
      this.initBricks();
    }

    draw() {
      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Draw paddle
      this.ctx.fillStyle = "#FFFFFF";
      this.ctx.fillRect(
        this.paddle.x,
        this.paddle.y,
        this.paddle.width,
        this.paddle.height
      );

      // Draw ball
      this.ctx.beginPath();
      this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
      this.ctx.fillStyle = "#FFFFFF";
      this.ctx.fill();
      this.ctx.closePath();

      // Draw bricks
      this.bricks.forEach((brick) => {
        if (brick.visible) {
          this.ctx.fillStyle = brick.color;
          this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
        }
      });
    }

    gameLoop() {
      if (this.gameStarted) {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
      }
    }
  }

  // Initialize game when component is mounted
  document.addEventListener("DOMContentLoaded", () => {
    new BrickBreakerGame();
  });
</script>

<style>
  .BrickBreakerGame_container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: 10;
  }

  #gameCanvas {
    background: #000000aa;
    display: block;
    margin: 0 auto;
    /* touch-action: none; */
    width: 100%;
    height: 100%;
  }

  .BrickBreakerGame_startBtn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 1rem 2rem;
    font-size: 1.5rem;
    background: linear-gradient(
      90deg,
      var(--color-violet) 0%,
      var(--color-blue) 100%
    );
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 10;
    transition: all 0.3s;
  }

  .BrickBreakerGame_startBtn:hover {
    transform: translate(-50%, -50%) scale(1.05);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
  }

  .BrickBreakerGame_stats {
    position: absolute;
    top: 1rem;
    right: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    color: white;
    font-size: 1.5rem;
    font-family: Arial, sans-serif;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
  }

  .BrickBreakerGame_score,
  .BrickBreakerGame_lives {
    text-align: right;
  }

  .BrickBreakerGame_container.hidden {
    display: none;
  }
</style>
